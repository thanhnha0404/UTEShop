const db = require("../models");
const { Op } = require("sequelize");
const notificationService = require("../services/notification.service");

// T·∫°o ƒë∆°n h√†ng m·ªõi
exports.createOrder = async (req, res) => {
  const t = await db.sequelize.transaction();
  try {
    const userId = req.user?.id;
    console.log("üîç User ID:", userId);
    console.log("üîç Request body:", req.body);
    
    if (!userId) return res.status(401).json({ message: "Unauthorized" });

    const { items, shippingAddress, shippingPhone, notes, paymentMethod, voucherCode } = req.body;

    if (!items || items.length === 0) {
      await t.rollback();
      return res.status(400).json({ message: "Gi·ªè h√†ng tr·ªëng" });
    }

    // T√≠nh t·ªïng ti·ªÅn
    const subtotal = items.reduce((sum, item) => sum + (item.price * item.quantity), 0);
    
    // T√≠nh ph√≠ v·∫≠n chuy·ªÉn theo ph∆∞∆°ng th·ª©c
    const shippingMethod = req.body.shippingMethod || 'standard';
    const shippingFee = items.length > 0 ? (shippingMethod === 'express' ? 15000 : 10000) : 0;
    
    // L·∫•y th√¥ng tin user ƒë·ªÉ ki·ªÉm tra xu hi·ªán c√≥
    const user = await db.User.findByPk(userId);
    const loyaltyPointsUsed = req.body.loyaltyPointsUsed || 0;
    
    // Validate and calculate voucher discount
    let voucherDiscount = 0;
    let appliedVoucher = null;
    
    if (voucherCode) {
      const voucher = await db.Voucher.findOne({
        where: { 
          code: voucherCode.toUpperCase(),
          status: 'active'
        }
      });
      
      if (voucher) {
        const now = new Date();
        
        // Check voucher validity
        if (voucher.end_date >= now && voucher.start_date <= now) {
          // Check usage limit
          if (!voucher.usage_limit || voucher.used_count < voucher.usage_limit) {
            // Check minimum order amount
            if (voucher.min_order_amount <= subtotal) {
              // Calculate discount
              if (voucher.discount_type === 'percentage') {
                voucherDiscount = Math.floor((subtotal * voucher.discount_value) / 100);
                if (voucher.max_discount_amount && voucherDiscount > voucher.max_discount_amount) {
                  voucherDiscount = voucher.max_discount_amount;
                }
              } else {
                voucherDiscount = Math.min(voucher.discount_value, subtotal);
              }
              appliedVoucher = voucher;
            }
          }
        }
      }
    }
    
    // T√≠nh t·ªïng ti·ªÅn sau khi tr·ª´ xu v√† voucher (1 xu = 1 VNƒê)
    const totalBeforeDiscount = subtotal + shippingFee;
    const total = Math.max(0, totalBeforeDiscount - loyaltyPointsUsed - voucherDiscount);
    
    // T√≠nh xu ƒë∆∞·ª£c t√≠ch l≈©y (20.000 VNƒê = 100 xu) - ch·ªâ t√≠nh tr√™n subtotal, kh√¥ng t√≠nh shipping fee
    const loyaltyPointsEarned = Math.floor(subtotal / 20000) * 100;

    // T·∫°o m√£ ƒë∆°n h√†ng
    const orderNumber = `UTE${Date.now()}${Math.floor(Math.random() * 1000)}`;

    // Ki·ªÉm tra xu c√≥ ƒë·ªß kh√¥ng
    if (loyaltyPointsUsed > user.loyalty_points) {
      await t.rollback();
      return res.status(400).json({ 
        message: "Kh√¥ng ƒë·ªß xu ƒë·ªÉ s·ª≠ d·ª•ng", 
        currentPoints: user.loyalty_points,
        requestedPoints: loyaltyPointsUsed
      });
    }

    // Ki·ªÉm tra t·ªìn kho tr∆∞·ªõc khi t·∫°o ƒë∆°n h√†ng
    for (const item of items) {
      const drink = await db.Drink.findByPk(item.drinkId, { transaction: t });
      if (!drink) {
        await t.rollback();
        return res.status(400).json({ message: `S·∫£n ph·∫©m ID ${item.drinkId} kh√¥ng t·ªìn t·∫°i` });
      }
      
      if (drink.stock < item.quantity) {
        await t.rollback();
        return res.status(400).json({ 
          message: `S·∫£n ph·∫©m "${drink.name}" ch·ªâ c√≤n ${drink.stock} s·∫£n ph·∫©m trong kho`,
          productName: drink.name,
          availableStock: drink.stock,
          requestedQuantity: item.quantity
        });
      }
    }

    // T·∫°o ƒë∆°n h√†ng
    console.log("üîç T·∫°o ƒë∆°n h√†ng v·ªõi d·ªØ li·ªáu:", {
      user_id: userId,
      order_number: orderNumber,
      status: "pending",
      payment_method: paymentMethod || "COD",
      subtotal,
      shipping_fee: shippingFee,
      total,
      loyalty_points_used: loyaltyPointsUsed,
      loyalty_points_earned: loyaltyPointsEarned,
      voucher_discount: voucherDiscount,
      shipping_address: shippingAddress,
      shipping_phone: shippingPhone,
      notes,
    });
    
    const order = await db.Order.create({
      user_id: userId,
      order_number: orderNumber,
      status: "pending",
      payment_method: paymentMethod || "COD",
      subtotal,
      shipping_fee: shippingFee,
      total,
      loyalty_points_used: loyaltyPointsUsed,
      loyalty_points_earned: loyaltyPointsEarned,
      voucher_discount: voucherDiscount,
      voucher_code: appliedVoucher ? appliedVoucher.code : null,
      shipping_address: shippingAddress,
      shipping_phone: shippingPhone,
      notes,
    }, { transaction: t });
    
    console.log("‚úÖ ƒê∆°n h√†ng ƒë√£ t·∫°o:", order.id);

    // T·∫°o order items
    const orderItems = await Promise.all(
      items.map(item =>
        db.OrderItem.create({
          order_id: order.id,
          drink_id: item.drinkId,
          quantity: item.quantity,
          price: item.price,
          size: item.size,
          ice_level: item.iceLevel,
          sugar_level: item.sugarLevel,
          notes: item.notes,
        }, { transaction: t })
      )
    );

    // C·∫≠p nh·∫≠t stock v√† sold cho t·ª´ng s·∫£n ph·∫©m
    for (const item of items) {
      await db.Drink.update(
        {
          stock: db.sequelize.literal(`stock - ${item.quantity}`),
          sold: db.sequelize.literal(`sold + ${item.quantity}`)
        },
        {
          where: { id: item.drinkId },
          transaction: t
        }
      );
    }

    // Update voucher usage count if voucher was applied
    if (appliedVoucher) {
      await db.Voucher.update(
        { used_count: db.sequelize.literal(`used_count + 1`) },
        { 
          where: { id: appliedVoucher.id },
          transaction: t 
        }
      );
    }

    // C·∫≠p nh·∫≠t xu c·ªßa user
    if (loyaltyPointsUsed > 0) {
      // Tr·ª´ xu ƒë√£ s·ª≠ d·ª•ng
      await user.update(
        { loyalty_points: db.sequelize.literal(`loyalty_points - ${loyaltyPointsUsed}`) },
        { transaction: t }
      );

      // Ghi log xu ƒë√£ s·ª≠ d·ª•ng
      await db.LoyaltyPoint.create({
        user_id: userId,
        points: user.loyalty_points - loyaltyPointsUsed,
        transaction_type: "used",
        amount: -loyaltyPointsUsed,
        used_in_order_id: order.id,
        description: `S·ª≠ d·ª•ng ${loyaltyPointsUsed} xu cho ƒë∆°n h√†ng ${orderNumber}`
      }, { transaction: t });
    }

    // C·ªông xu m·ªõi v√†o t√†i kho·∫£n user
    if (loyaltyPointsEarned > 0) {
      // C·∫≠p nh·∫≠t xu trong t√†i kho·∫£n user
      await user.update(
        { loyalty_points: db.sequelize.literal(`loyalty_points + ${loyaltyPointsEarned}`) },
        { transaction: t }
      );

      // Ghi log xu ƒë√£ t√≠ch l≈©y
      await db.LoyaltyPoint.create({
        user_id: userId,
        points: user.loyalty_points - loyaltyPointsUsed + loyaltyPointsEarned,
        transaction_type: "earned",
        amount: loyaltyPointsEarned,
        earned_from_order_id: order.id,
        description: `T√≠ch l≈©y ${loyaltyPointsEarned} xu t·ª´ ƒë∆°n h√†ng ${orderNumber}`
      }, { transaction: t });
    }

    // X√≥a gi·ªè h√†ng
    await db.CartItem.destroy({
      where: { user_id: userId },
      transaction: t
    });

    await t.commit();

    // L·∫•y th√¥ng tin ƒë∆°n h√†ng ƒë·∫ßy ƒë·ªß
    const fullOrder = await db.Order.findByPk(order.id, {
      include: [
        {
          model: db.OrderItem,
          as: "orderItems",
          include: [
            {
              model: db.Drink,
              as: "drink",
              attributes: ["id", "name", "image_url"]
            }
          ]
        }
      ]
    });

    // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi frontend
    const orderData = {
      id: fullOrder.id,
      order_number: fullOrder.order_number,
      status: fullOrder.status,
      payment_method: fullOrder.payment_method,
      subtotal: Number(fullOrder.subtotal),
      shipping_fee: Number(fullOrder.shipping_fee),
      total: Number(fullOrder.total),
      shipping_address: fullOrder.shipping_address,
      shipping_phone: fullOrder.shipping_phone,
      notes: fullOrder.notes,
      created_at: fullOrder.created_at,
      updated_at: fullOrder.updated_at,
      items: fullOrder.orderItems?.map(item => ({
        id: item.id,
        drinkId: item.drink_id,
        quantity: item.quantity,
        price: Number(item.price),
        name: item.drink?.name,
        image_url: item.drink?.image_url,
        size: item.size,
        iceLevel: item.ice_level,
        sugarLevel: item.sugar_level,
        notes: item.notes
      })) || []
    };

    // T·∫°o th√¥ng b√°o cho user v·ªÅ ƒë∆°n h√†ng m·ªõi
    try {
      const notificationResult = await notificationService.createOrderNotification(userId, {
        id: order.id,
        order_number: order.order_number,
        total_amount: total
      });
      
      if (notificationResult.success && global.io) {
        await notificationService.sendRealTimeNotification(global.io, userId, notificationResult.notification);
      }
    } catch (notificationError) {
      console.error('Error creating order notification:', notificationError);
      // Kh√¥ng throw error v√¨ ƒë∆°n h√†ng ƒë√£ t·∫°o th√†nh c√¥ng
    }

    return res.json({
      message: "ƒê·∫∑t h√†ng th√†nh c√¥ng",
      order: orderData
    });

  } catch (err) {
    await t.rollback();
    return res.status(500).json({
      message: "L·ªói khi t·∫°o ƒë∆°n h√†ng",
      error: err?.message || String(err)
    });
  }
};

// L·∫•y danh s√°ch ƒë∆°n h√†ng c·ªßa user
exports.getUserOrders = async (req, res) => {
  try {
    const userId = req.user?.id;
    if (!userId) return res.status(401).json({ message: "Unauthorized" });

    const { status, page = 1, limit = 10 } = req.query;
    const offset = (page - 1) * limit;

    const whereClause = { 
      user_id: userId,
      is_hidden: false  // Ch·ªâ l·∫•y ƒë∆°n h√†ng kh√¥ng b·ªã ·∫©n
    };
    if (status && status !== "all") {
      whereClause.status = status;
    }

    const orders = await db.Order.findAndCountAll({
      where: whereClause,
      include: [
        {
          model: db.OrderItem,
          as: "orderItems",
          include: [
            {
              model: db.Drink,
              as: "drink",
              attributes: ["id", "name", "image_url"]
            }
          ]
        }
      ],
      order: [["created_at", "DESC"]],
      limit: parseInt(limit),
      offset: parseInt(offset)
    });

    // Chuy·ªÉn ƒë·ªïi d·ªØ li·ªáu ƒë·ªÉ t∆∞∆°ng th√≠ch v·ªõi frontend
    const formattedOrders = orders.rows.map(order => ({
      id: order.id,
      order_number: order.order_number,
      status: order.status,
      payment_method: order.payment_method,
      subtotal: Number(order.subtotal),
      shipping_fee: Number(order.shipping_fee),
      total: Number(order.total),
      shipping_address: order.shipping_address,
      shipping_phone: order.shipping_phone,
      notes: order.notes,
      created_at: order.created_at,
      updated_at: order.updated_at,
      orderItems: order.orderItems?.map(item => ({
        id: item.id,
        drink_id: item.drink_id,
        quantity: item.quantity,
        price: Number(item.price),
        size: item.size,
        ice_level: item.ice_level,
        sugar_level: item.sugar_level,
        notes: item.notes,
        drink: item.drink
      })) || []
    }));

    return res.json({
      orders: formattedOrders,
      total: orders.count,
      page: parseInt(page),
      limit: parseInt(limit),
      totalPages: Math.ceil(orders.count / limit)
    });

  } catch (err) {
    return res.status(500).json({
      message: "L·ªói khi l·∫•y danh s√°ch ƒë∆°n h√†ng",
      error: err?.message || String(err)
    });
  }
};

// L·∫•y chi ti·∫øt ƒë∆°n h√†ng
exports.getOrderDetail = async (req, res) => {
  try {
    const userId = req.user?.id;
    const { orderId } = req.params;

    if (!userId) return res.status(401).json({ message: "Unauthorized" });

    const order = await db.Order.findOne({
      where: {
        id: orderId,
        user_id: userId
      },
      include: [
        {
          model: db.OrderItem,
          as: "orderItems",
          include: [
            {
              model: db.Drink,
              as: "drink",
              attributes: ["id", "name", "image_url", "description"]
            }
          ]
        }
      ]
    });

    if (!order) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });
    }

    return res.json({ order });

  } catch (err) {
    return res.status(500).json({
      message: "L·ªói khi l·∫•y chi ti·∫øt ƒë∆°n h√†ng",
      error: err?.message || String(err)
    });
  }
};

// H·ªßy ƒë∆°n h√†ng
exports.cancelOrder = async (req, res) => {
  const t = await db.sequelize.transaction();
  try {
    const userId = req.user?.id;
    const { orderId } = req.params;
    const { reason } = req.body;

    if (!userId) return res.status(401).json({ message: "Unauthorized" });

    const order = await db.Order.findOne({
      where: {
        id: orderId,
        user_id: userId
      },
      transaction: t,
      lock: true
    });

    if (!order) {
      await t.rollback();
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });
    }

    // Ki·ªÉm tra th·ªùi gian h·ªßy (ch·ªâ ƒë∆∞·ª£c h·ªßy trong 5 ph√∫t ƒë·∫ßu)
    const orderTime = new Date(order.created_at);
    const now = new Date();
    const timeDiff = (now - orderTime) / (1000 * 60); // ph√∫t

    if (timeDiff > 5) {
      await t.rollback();
      return res.status(400).json({
        message: "Kh√¥ng th·ªÉ h·ªßy ƒë∆°n h√†ng sau 5 ph√∫t. Vui l√≤ng li√™n h·ªá shop ƒë·ªÉ h·ªßy ƒë∆°n."
      });
    }

    // Ki·ªÉm tra tr·∫°ng th√°i ƒë∆°n h√†ng
    if (order.status === "cancelled") {
      await t.rollback();
      return res.status(400).json({ message: "ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c h·ªßy" });
    }

    if (["shipping", "delivered"].includes(order.status)) {
      await t.rollback();
      return res.status(400).json({
        message: "Kh√¥ng th·ªÉ h·ªßy ƒë∆°n h√†ng ƒëang giao ho·∫∑c ƒë√£ giao"
      });
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng
    await order.update({
      status: "cancelled",
      cancelled_at: new Date(),
      cancelled_reason: reason || "Ng∆∞·ªùi d√πng h·ªßy ƒë∆°n"
    }, { transaction: t });

    await t.commit();

    return res.json({ message: "H·ªßy ƒë∆°n h√†ng th√†nh c√¥ng" });

  } catch (err) {
    await t.rollback();
    return res.status(500).json({
      message: "L·ªói khi h·ªßy ƒë∆°n h√†ng",
      error: err?.message || String(err)
    });
  }
};

// G·ª≠i y√™u c·∫ßu h·ªßy ƒë∆°n (cho ƒë∆°n ƒë√£ chuy·ªÉn sang b∆∞·ªõc 3)
exports.requestCancelOrder = async (req, res) => {
  try {
    const userId = req.user?.id;
    const { orderId } = req.params;
    const { reason } = req.body;

    if (!userId) return res.status(401).json({ message: "Unauthorized" });

    const order = await db.Order.findOne({
      where: {
        id: orderId,
        user_id: userId
      }
    });

    if (!order) {
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });
    }

    // Ch·ªâ cho ph√©p g·ª≠i y√™u c·∫ßu h·ªßy cho ƒë∆°n ƒë√£ chuy·ªÉn sang b∆∞·ªõc 3 tr·ªü l√™n
    if (!["preparing", "shipping"].includes(order.status)) {
      return res.status(400).json({
        message: "Ch·ªâ c√≥ th·ªÉ g·ª≠i y√™u c·∫ßu h·ªßy cho ƒë∆°n h√†ng ƒëang chu·∫©n b·ªã ho·∫∑c ƒëang giao"
      });
    }

    // TODO: G·ª≠i th√¥ng b√°o cho admin v·ªÅ y√™u c·∫ßu h·ªßy ƒë∆°n
    // C√≥ th·ªÉ l∆∞u v√†o b·∫£ng notifications ho·∫∑c g·ª≠i email

    return res.json({
      message: "ƒê√£ g·ª≠i y√™u c·∫ßu h·ªßy ƒë∆°n. Shop s·∫Ω xem x√©t v√† ph·∫£n h·ªìi s·ªõm nh·∫•t."
    });

  } catch (err) {
    return res.status(500).json({
      message: "L·ªói khi g·ª≠i y√™u c·∫ßu h·ªßy ƒë∆°n",
      error: err?.message || String(err)
    });
  }
};

// C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng (cho admin)
exports.updateOrderStatus = async (req, res) => {
  const t = await db.sequelize.transaction();
  try {
    const { orderId } = req.params;
    const { status } = req.body;

    const validStatuses = ["pending", "confirmed", "preparing", "shipping", "delivered", "cancelled"];
    if (!validStatuses.includes(status)) {
      await t.rollback();
      return res.status(400).json({ message: "Tr·∫°ng th√°i kh√¥ng h·ª£p l·ªá" });
    }

    const order = await db.Order.findByPk(orderId, {
      transaction: t,
      lock: true
    });

    if (!order) {
      await t.rollback();
      return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });
    }

    const updateData = { status };
    const now = new Date();

    // C·∫≠p nh·∫≠t th·ªùi gian t∆∞∆°ng ·ª©ng v·ªõi tr·∫°ng th√°i
    switch (status) {
      case "confirmed":
        updateData.confirmed_at = now;
        // C·ªông xu khi ƒë∆°n h√†ng ƒë∆∞·ª£c x√°c nh·∫≠n
        if (order.loyalty_points_earned > 0) {
          const user = await db.User.findByPk(order.user_id, { transaction: t });
          await user.update(
            { loyalty_points: db.sequelize.literal(`loyalty_points + ${order.loyalty_points_earned}`) },
            { transaction: t }
          );
        }
        break;
      case "preparing":
        updateData.preparing_at = now;
        break;
      case "shipping":
        updateData.shipping_at = now;
        break;
      case "delivered":
        updateData.delivered_at = now;
        break;
      case "cancelled":
        updateData.cancelled_at = now;
        // Ho√†n l·∫°i stock v√† xu khi h·ªßy ƒë∆°n h√†ng
        const orderItems = await db.OrderItem.findAll({
          where: { order_id: orderId },
          transaction: t
        });
        
        for (const item of orderItems) {
          await db.Drink.update(
            {
              stock: db.sequelize.literal(`stock + ${item.quantity}`),
              sold: db.sequelize.literal(`sold - ${item.quantity}`)
            },
            {
              where: { id: item.drink_id },
              transaction: t
            }
          );
        }
        
        // Ho√†n l·∫°i xu ƒë√£ s·ª≠ d·ª•ng
        if (order.loyalty_points_used > 0) {
          const user = await db.User.findByPk(order.user_id, { transaction: t });
          await user.update(
            { loyalty_points: db.sequelize.literal(`loyalty_points + ${order.loyalty_points_used}`) },
            { transaction: t }
          );
        }
        break;
    }

    await order.update(updateData, { transaction: t });
    await t.commit();

    return res.json({ message: "C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng th√†nh c√¥ng" });

  } catch (err) {
    await t.rollback();
    return res.status(500).json({
      message: "L·ªói khi c·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng",
      error: err?.message || String(err)
    });
  }
};

// T·ª± ƒë·ªông x√°c nh·∫≠n ƒë∆°n h√†ng sau 5 ph√∫t
exports.autoConfirmOrders = async () => {
  try {
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000);
    
    const orders = await db.Order.findAll({
      where: {
        status: "pending",
        created_at: {
          [Op.lte]: fiveMinutesAgo
        }
      }
    });

    for (const order of orders) {
      await order.update({
        status: "confirmed",
        confirmed_at: new Date()
      });

      // T·∫°o th√¥ng b√°o x√°c nh·∫≠n ƒë∆°n h√†ng
      try {
        const notificationResult = await notificationService.createOrderConfirmationNotification(order.user_id, {
          id: order.id,
          order_number: order.order_number,
          total_amount: order.total_amount
        });
        
        if (notificationResult.success && global.io) {
          await notificationService.sendRealTimeNotification(global.io, order.user_id, notificationResult.notification);
        }
      } catch (notificationError) {
        console.error('Error creating confirmation notification:', notificationError);
      }
    }

    console.log(`‚úÖ T·ª± ƒë·ªông x√°c nh·∫≠n ${orders.length} ƒë∆°n h√†ng`);
  } catch (err) {
    console.error("‚ùå L·ªói t·ª± ƒë·ªông x√°c nh·∫≠n ƒë∆°n h√†ng:", err);
  }
};

// // L·∫•y danh s√°ch ƒë∆°n h√†ng c·ªßa user
// exports.getUserOrders = async (req, res) => {
//   try {
//     const userId = req.user?.id;
//     if (!userId) return res.status(401).json({ message: "Unauthorized" });

//     const orders = await db.Order.findAll({
//       where: { user_id: userId },
//       include: [
//         {
//           model: db.OrderItem,
//           as: "orderItems",
//           include: [
//             {
//               model: db.Drink,
//               as: "drink",
//               attributes: ["id", "name", "image_url"]
//             }
//           ]
//         }
//       ],
//       order: [["created_at", "DESC"]]
//     });

//     return res.json({
//       orders: orders
//     });

//   } catch (err) {
//     return res.status(500).json({
//       message: "L·ªói khi l·∫•y danh s√°ch ƒë∆°n h√†ng",
//       error: err?.message || String(err)
//     });
//   }
// };
